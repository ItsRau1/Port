"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const jsx_runtime_1 = require("react/jsx-runtime");
const clsx_1 = __importDefault(require("clsx"));
const react_1 = __importDefault(require("react"));
const defaults_1 = require("./defaults");
const handleAction_1 = require("./helpers/handleAction");
const handleLifeCycle_1 = require("./helpers/handleLifeCycle");
const handleWord_1 = require("./helpers/handleWord");
const types_1 = require("./types");
const CopyData_1 = require("./utils/CopyData");
const Cursor_1 = require("./utils/Cursor");
// https://css-tricks.com/snippets/css/typewriter-effect/
class Typewriter extends react_1.default.Component {
    constructor() {
        super(...arguments);
        this.mDefaultPackData = {
            // Since we want to support deleting, we must have a copy data and perform delete on it. We will restore original data after rotate through all data.
            copyDataToRotate: (0, CopyData_1.deepCopyData)(this.props.dataToRotate),
            internalBlockPointer: 0,
            blockPointer: 0,
            HTMLPointer: 0,
            currentHTML: "",
            currentDataRotateIndex: 0,
            isDeleting: false,
            deleteCache: {
                original_internalBlockPointer: -1,
                original_blockPointer: -1
            },
            cursorCache: { prevCursorClass: "" },
            timeoutBlinkCursor: -1,
            timeoutTick: -1 // Remain the same even after reseting
        };
        this.mPack = Object.assign({ containerRef: react_1.default.createRef(), contentRef: react_1.default.createRef(), cursorRef: react_1.default.createRef() }, this.mDefaultPackData);
    }
    componentDidMount() {
        const { start } = this.props;
        const isStart = start === undefined ? defaults_1.DefaultSetting.start : start;
        if (isStart) {
            (0, Cursor_1.blinkCursor)(this.props, this.mPack);
            this.tick();
        }
    }
    componentDidUpdate(prevProps) {
        const { start } = this.props;
        const { start: prevStart } = prevProps;
        if (!prevStart && start) {
            // Reset data in pack if start flag is reseted
            this.mPack = Object.assign(Object.assign({}, this.mPack), this.mDefaultPackData);
            (0, Cursor_1.blinkCursor)(this.props, this.mPack);
            this.tick();
        }
    }
    componentWillUnmount() {
        (0, handleLifeCycle_1.resetPack)(this.mPack);
        window.clearTimeout(this.mPack.timeoutTick);
    }
    tick() {
        const rotateDataIndex = this.mPack.currentDataRotateIndex % this.mPack.copyDataToRotate.length;
        const textBlocks = this.mPack.copyDataToRotate[rotateDataIndex];
        let currentBlock = textBlocks[this.mPack.blockPointer];
        // *** Handle action ***
        if (currentBlock && currentBlock.type === "action") {
            /**
             * If deleting (i.e: Currently traversing blocks from right to left):
             * - Don't even care about actions
             * - Move to previous block
             *    - Case 1: If previous block is WordBlock => Don't forget to set internal block pointer
             *    - Case 2: If block pointer is now out of bound => This means we have finished deleting everything => Move to next data array
             * - Call tick again to handle this new block
             */
            if (this.mPack.isDeleting) {
                this.mPack.blockPointer--;
                // Case 1
                currentBlock = textBlocks[this.mPack.blockPointer];
                if (currentBlock.type === "word") {
                    this.mPack.internalBlockPointer = currentBlock.text.length - 1;
                }
                // Case 2
                if (this.mPack.blockPointer === -1) {
                    this.mPack.currentDataRotateIndex++;
                }
                this.tick();
                return;
            }
            (0, handleAction_1.handleAction)(this.props, this.mPack, () => this.tick());
        }
        // *** Handle word / out-of-bound block ***
        else {
            (0, handleWord_1.handleWord)(this.props, this.mPack, () => this.tick());
        }
    }
    render() {
        var _a;
        const { containerClass, contentClass, cursorClass, cursor } = this.props;
        const { containerRef, contentRef, cursorRef } = this.mPack;
        return ((0, jsx_runtime_1.jsxs)("span", Object.assign({ ref: containerRef, className: (0, clsx_1.default)(types_1.TypewriterClassNames.Container, containerClass) }, { children: [(0, jsx_runtime_1.jsx)("span", { ref: contentRef, className: (0, clsx_1.default)(types_1.TypewriterClassNames.Content, contentClass) }), (0, jsx_runtime_1.jsx)("span", Object.assign({ ref: cursorRef, className: (0, clsx_1.default)(types_1.TypewriterClassNames.Cursor, cursorClass) }, { children: (_a = cursor === null || cursor === void 0 ? void 0 : cursor.char) !== null && _a !== void 0 ? _a : defaults_1.DefaultSetting.cursor.char }))] })));
    }
}
exports.default = Typewriter;
