"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleWord = void 0;
const defaults_1 = require("../../defaults");
const CopyData_1 = require("../../utils/CopyData");
const Cursor_1 = require("../../utils/Cursor");
const WordBlock_1 = require("../../utils/WordBlock");
const addChar_1 = require("./addChar");
const deleteChar_1 = require("./deleteChar");
const handleWord = (props, pack, moveOn) => {
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    const { typeVariance, maxTypeSpeed, deleteVariance, maxDeleteSpeed, timeBeforeWriteNewRotateData, timeBeforeDelete, loop } = props;
    const isLoop = loop === undefined ? defaults_1.DefaultSetting.loop : loop;
    const { current: contentCurrent } = pack.contentRef;
    if (!contentCurrent) {
        return;
    }
    const rotateDataIndex = pack.currentDataRotateIndex % pack.copyDataToRotate.length;
    const textBlocks = pack.copyDataToRotate[rotateDataIndex];
    // console.log(pack.isDeleting ? "delete" : "add", pack.currentHTML);
    /**
     *  If we are deleting and internal block pointer === -1:
     *  => We have finished removing this block
     *  => Move backward to next non-empty WordBlock
     */
    if (pack.isDeleting && pack.internalBlockPointer === -1) {
        (0, WordBlock_1.moveToPreviousNonEmptyWordBlock)(pack);
    }
    /**
     *  If we are deleting and block pointer === -1: This case happens as a result of moving to previous non-empty WordBlock
     *  => We have traversing all blocks from right to left
     *  => Move to next data in rotation cycle (Remember to reset necessary variables before handling next data)
     */
    if (pack.isDeleting && pack.blockPointer === -1) {
        // Reset necessary variables
        pack.internalBlockPointer = 0;
        pack.blockPointer = 0;
        pack.HTMLPointer = 0;
        pack.currentHTML = "";
        pack.isDeleting = false;
        pack.copyDataToRotate = (0, CopyData_1.deepCopyData)(props.dataToRotate);
        // Check out next data
        pack.currentDataRotateIndex++;
        const waitTime = timeBeforeWriteNewRotateData !== null && timeBeforeWriteNewRotateData !== void 0 ? timeBeforeWriteNewRotateData : defaults_1.DefaultSetting.timeBeforeWriteNewRotateData;
        pack.timeoutTick = window.setTimeout(() => {
            moveOn();
        }, waitTime);
        return;
    }
    const oldBlock = textBlocks[pack.blockPointer];
    /**
     *  If we are deleting and current block is empty and no span class:
     *  => We continue moving backward to next non-empty WordBlock
     */
    if (pack.isDeleting && oldBlock.text === "" && !oldBlock.spanClass) {
        (0, WordBlock_1.moveToPreviousNonEmptyWordBlock)(pack);
    }
    const newBlock = textBlocks[pack.blockPointer];
    // *** Set cursor color ***
    (0, Cursor_1.setCursorClass)(props, pack);
    // *** Adding ***
    if (!pack.isDeleting) {
        // Note: Since this is when we are not deleting, all moving above is not applicable.
        (0, addChar_1.addChar)(props, pack);
        /**
         *  When we finish adding text from WordBlock / WordBlock is empty:
         *  - Move block pointer forward to check new block
         *  - Set internal block pointer to 0
         */
        if (pack.internalBlockPointer === newBlock.text.length || newBlock.text.length === 0) {
            pack.blockPointer++;
            pack.internalBlockPointer = 0;
        }
    }
    // *** Deleting ***
    else {
        (0, deleteChar_1.deleteChar)(props, pack);
    }
    // *** Update HTML ***
    contentCurrent.innerHTML = pack.currentHTML;
    let waitTime = 0;
    // *** Calculate wait time during typing ***
    const final_typeVariance = (_c = (_b = (_a = newBlock.override) === null || _a === void 0 ? void 0 : _a.typeVariance) !== null && _b !== void 0 ? _b : typeVariance) !== null && _c !== void 0 ? _c : defaults_1.DefaultSetting.typeVariance;
    const final_maxTypeSpeed = (_f = (_e = (_d = newBlock.override) === null || _d === void 0 ? void 0 : _d.maxTypespeed) !== null && _e !== void 0 ? _e : maxTypeSpeed) !== null && _f !== void 0 ? _f : defaults_1.DefaultSetting.maxTypeSpeed;
    waitTime = final_maxTypeSpeed - Math.random() * final_typeVariance;
    // *** Calculate wait time during deleting ***
    if (pack.isDeleting && pack.currentHTML !== "") {
        const final_deleteVariance = (_j = (_h = (_g = newBlock.override) === null || _g === void 0 ? void 0 : _g.deleteVariance) !== null && _h !== void 0 ? _h : deleteVariance) !== null && _j !== void 0 ? _j : defaults_1.DefaultSetting.deleteVariance;
        const final_maxDeleteSpeed = (_m = (_l = (_k = newBlock.override) === null || _k === void 0 ? void 0 : _k.maxDeleteSpeed) !== null && _l !== void 0 ? _l : maxDeleteSpeed) !== null && _m !== void 0 ? _m : defaults_1.DefaultSetting.maxDeleteSpeed;
        waitTime = final_maxDeleteSpeed - Math.random() * final_deleteVariance;
    }
    /**
     *  If we are deleting and HTML is empty: This case can happen as a result of deleteChar function
     *  => We have finished deleting all blocks
     *  => Move to next data in rotation cycle (Remember to reset necessary variables before handling next data)
     */
    if (pack.isDeleting && pack.currentHTML === "") {
        pack.internalBlockPointer = 0;
        pack.blockPointer = 0;
        pack.HTMLPointer = 0;
        pack.currentHTML = "";
        pack.isDeleting = false;
        pack.copyDataToRotate = (0, CopyData_1.deepCopyData)(props.dataToRotate);
        pack.currentDataRotateIndex++; // Check out next data
        waitTime = timeBeforeWriteNewRotateData !== null && timeBeforeWriteNewRotateData !== void 0 ? timeBeforeWriteNewRotateData : defaults_1.DefaultSetting.timeBeforeWriteNewRotateData;
    }
    /**
     *  If we are not deleting (adding) and block pointer is out-of-bound:
     *  => We have finished traversing all blocks from left to right
     *      - Move HTML pointer backward (b/c HTML is pointing to a new blank position while adding)
     *      - Move internal block pointer backward (in case last adding block is a WordBlock)
     *      - Change signal to DELETING
     */
    if (!pack.isDeleting && pack.blockPointer === textBlocks.length) {
        // Check loop and if it is last data to rotate
        if (!isLoop && pack.currentDataRotateIndex === pack.copyDataToRotate.length - 1) {
            return;
        }
        pack.HTMLPointer--;
        pack.internalBlockPointer--;
        pack.isDeleting = true;
        waitTime = timeBeforeDelete !== null && timeBeforeDelete !== void 0 ? timeBeforeDelete : defaults_1.DefaultSetting.timeBeforeDelete;
    }
    pack.timeoutTick = window.setTimeout(() => {
        moveOn();
    }, waitTime);
};
exports.handleWord = handleWord;
