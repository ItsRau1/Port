"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleDelete = void 0;
const defaults_1 = require("../../defaults");
const Cursor_1 = require("../../utils/Cursor");
const WordBlock_1 = require("../../utils/WordBlock");
const deleteChar_1 = require("../handleWord/deleteChar");
// --------- Handle Delete --------
const handleDelete = (props, pack, moveOn, amount) => {
    var _a, _b, _c, _d, _e, _f;
    const { deleteVariance, maxDeleteSpeed, timeBeforeDelete } = props;
    const { current: contentCurrent } = pack.contentRef;
    if (!contentCurrent) {
        return;
    }
    const rotateDataIndex = pack.currentDataRotateIndex % pack.copyDataToRotate.length;
    const textBlocks = pack.copyDataToRotate[rotateDataIndex];
    // 2 base cases
    /**
     *  Base case 1:
     *  - If amount <= 0 => Finish delete action & Move on.
     *  - Why not === only? We account in invalid inputs, too (e.g: input amount = -1)
     */
    if (amount <= 0) {
        prepareToMoveOn(pack);
        if (pack.blockPointer === textBlocks.length - 1) {
            // If current action is the last block, set wait time to timeBeforeDelete
            const waitTime = timeBeforeDelete !== null && timeBeforeDelete !== void 0 ? timeBeforeDelete : defaults_1.DefaultSetting.timeBeforeDelete;
            pack.timeoutTick = window.setTimeout(() => {
                moveOn();
            }, waitTime);
        }
        else {
            // Else, just move on as usual
            moveOn();
        }
        return;
    }
    const oldBlock = textBlocks[pack.blockPointer];
    /**
     *  3 cases:
     *    1. Current block is an action: Meaning there are nothing to delete
     *    2. Internal block pointer is out of bound: Happens when we finish deleting a WordBlock
     *    3. Text is empty:
     *        - Happens when we revisit a deleted WordBlock / The block itself is empty from beginning
     *        => Either way, we don't care. We only care about blocks with letter to delete
     */
    if (oldBlock.type !== "word" || pack.internalBlockPointer === -1 || oldBlock.text === "") {
        (0, WordBlock_1.moveToPreviousNonEmptyWordBlock)(pack);
    }
    /**
     *  Base case 2:
     *  - If we already traversed all blocks from right to left
     */
    if (pack.blockPointer === -1) {
        prepareToMoveOn(pack);
        moveOn();
        return;
    }
    /**
     *  This takes in account the 3 cases changing our "current" block.
     */
    const newBlock = textBlocks[pack.blockPointer];
    // *** Set cursor color ***
    (0, Cursor_1.setCursorClass)(props, pack);
    // *** Delete ***
    (0, deleteChar_1.deleteChar)(props, pack);
    /**
     *  After deleting 1 character in HTML, we want to delete that 1 character in WordBlock to keep record for later ActionBlock's.
     */
    newBlock.text = newBlock.text.substring(0, newBlock.text.length - 1);
    // *** Update HTML ***
    contentCurrent.innerHTML = pack.currentHTML;
    let waitTime = 0;
    const final_deleteVariance = (_c = (_b = (_a = newBlock.override) === null || _a === void 0 ? void 0 : _a.deleteVariance) !== null && _b !== void 0 ? _b : deleteVariance) !== null && _c !== void 0 ? _c : defaults_1.DefaultSetting.deleteVariance;
    const final_maxDeleteSpeed = (_f = (_e = (_d = newBlock.override) === null || _d === void 0 ? void 0 : _d.maxDeleteSpeed) !== null && _e !== void 0 ? _e : maxDeleteSpeed) !== null && _f !== void 0 ? _f : defaults_1.DefaultSetting.maxDeleteSpeed;
    waitTime = final_maxDeleteSpeed - Math.random() * final_deleteVariance;
    /**
     *  Call handleDelete again with (amount - 1)
     */
    pack.timeoutTick = window.setTimeout(() => {
        (0, exports.handleDelete)(props, pack, moveOn, amount - 1);
    }, waitTime);
};
exports.handleDelete = handleDelete;
// --------- Helpers ---------
const prepareToMoveOn = (pack) => {
    const rotateDataIndex = pack.currentDataRotateIndex % pack.copyDataToRotate.length;
    const textBlocks = pack.copyDataToRotate[rotateDataIndex];
    /**
     *  We move HTML pointer forward so that later ADDING would add in new position.
     */
    pack.HTMLPointer++;
    /**
     *  If current block is a span and we have not deleted everything inside this span
     *  => Move HTML pointer outside </span> so that ADDING would add in new position
     */
    const currentBlock = textBlocks[pack.blockPointer];
    if (pack.blockPointer !== -1 && currentBlock.spanClass && currentBlock.text !== "") {
        pack.HTMLPointer += `/span> `.length;
    }
    /**
     *  Restore original pointers
     */
    pack.internalBlockPointer = pack.deleteCache.original_internalBlockPointer;
    pack.blockPointer = pack.deleteCache.original_blockPointer;
    /**
     *  If current action is the last block
     *  =>  - Switch to delete mode
     *      - Move HTML pointer back for deleting (b/c from above, HTML pointer is pointing to a new blank position)
     */
    if (pack.blockPointer === textBlocks.length - 1) {
        pack.isDeleting = true;
        pack.HTMLPointer--;
    }
    else {
        /**
         *  Else:
         *  - Move block pointer forward to check next block
         *  - Set internal block pointer to 0 (in case next block is a WordBlock)
         */
        pack.blockPointer++;
        pack.internalBlockPointer = 0;
    }
};
